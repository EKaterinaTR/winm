# Общие настройки
namespace: winm
nameOverride: ""
fullnameOverride: ""

# Server (FastAPI)
server:
  enabled: true
  replicaCount: 1
  image:
    repository: winm-server
    tag: latest
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    port: 8000
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
  neo4j:
    uri: "bolt://neo4j:7687"
    user: "neo4j"
  probes:
    liveness:
      path: /health
      port: 8000
      initialDelaySeconds: 10
      periodSeconds: 10
    readiness:
      path: /health
      port: 8000
      initialDelaySeconds: 5
      periodSeconds: 5
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 5
    targetCPUUtilizationPercentage: 70
  llmServiceUrl: "http://winm-llm:8001"
  # JWT: auth_disabled=true отключает проверку токена (удобно для локальной разработки).
  authDisabled: false

# Ingress: внешний доступ к API (HTTPS при наличии TLS)
ingress:
  enabled: true
  className: nginx
  hosts:
    - host: winm-api.local
  annotations: {}
  # Пример с cert-manager (Let's Encrypt): раскомментировать и задать свой host + issuer.
  # annotations:
  #   cert-manager.io/cluster-issuer: letsencrypt-prod
  # hosts:
  #   - host: api.yourdomain.com
  # tls:
  #   - secretName: winm-server-tls
  #     hosts:
  #       - api.yourdomain.com
  tls: []
  # Вариант с готовым TLS-сертификатом (secret создаётся вручную или через sealed-secrets):
  # tls:
  #   - secretName: winm-server-tls
  #     hosts:
  #       - winm-api.local
consumer:
  enabled: true
  replicaCount: 1
  image:
    repository: winm-consumer
    tag: latest
    pullPolicy: IfNotPresent
  exportDir: "/app/exports"
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
  probes:
    liveness:
      exec:
        command: ["pgrep", "-f", "app.main"]
      initialDelaySeconds: 15
      periodSeconds: 15
    readiness:
      exec:
        command: ["pgrep", "-f", "app.main"]
      initialDelaySeconds: 5
      periodSeconds: 10

# Секреты: имя существующего Secret в namespace (создаётся вручную или через Sealed Secrets).
# При neo4j.enabled/rabbitmq.enabled и create: false в секрете нужны также: neo4j-auth (формат "neo4j/<password>"), rabbitmq-default-user, rabbitmq-default-pass.
# Для JWT: jwt-secret-key, api-username, api-password.
# Ключи: neo4j-password, neo4j-auth, rabbitmq-url, ..., gigachat-credentials (optional), jwt-secret-key, api-username, api-password
secrets:
  name: winm-secrets
  # Создавать Secret из values (только для dev; в prod использовать внешний Secret).
  create: false
  # Если create: true — задать через -f values-secret.yaml или env (не коммитить).
  neo4jPassword: ""
  rabbitmqUrl: "amqp://guest:guest@rabbitmq:5672/"
  gigachatCredentials: ""
  jwtSecretKey: ""
  apiUsername: "api"
  apiPassword: "api"

# LLM service (GigaChat)
llm:
  enabled: true
  replicaCount: 1
  image:
    repository: winm-llm
    tag: latest
    pullPolicy: IfNotPresent
  service:
    port: 8001
  resources:
    requests:
      memory: "256Mi"
      cpu: "100m"
  probes:
    liveness:
      path: /health
      port: 8001
      initialDelaySeconds: 10
      periodSeconds: 15
    readiness:
      path: /health
      port: 8001
      initialDelaySeconds: 5
      periodSeconds: 10

# Глобальный registry: если задан, образы будут <registry>/<repository>:<tag>
# Пример: ghcr.io/myorg/winm-server
global:
  imageRegistry: ""

# Neo4j — разворачивается из образа с персистентным томом (опционально)
neo4j:
  enabled: true
  image:
    repository: neo4j
    tag: "5"
    pullPolicy: IfNotPresent
  persistence:
    enabled: true
    size: 10Gi

# RabbitMQ — разворачивается из образа с персистентным томом (опционально)
rabbitmq:
  enabled: true
  image:
    repository: rabbitmq
    tag: "3-management"
    pullPolicy: IfNotPresent
  persistence:
    enabled: true
    size: 5Gi
  auth:
    user: guest
    password: guest

# RBAC: ServiceAccount для server, consumer, llm + Role + RoleBinding (минимальные права)
rbac:
  enabled: true
